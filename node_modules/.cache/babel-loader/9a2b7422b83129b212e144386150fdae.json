{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bind/callBound');\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n/*\r\n * This function traverses the list returning the node corresponding to the\r\n * given key.\r\n *\r\n * That node is also moved to the head of the list, so that if it's accessed\r\n * again we don't need to traverse the whole list. By doing so, all the recently\r\n * used nodes can be accessed relatively quickly.\r\n */\n\nvar listGetNode = function (list, key) {\n  // eslint-disable-line consistent-return\n  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n    if (curr.key === key) {\n      prev.next = curr.next;\n      curr.next = list.next;\n      list.next = curr; // eslint-disable-line no-param-reassign\n\n      return curr;\n    }\n  }\n};\n\nvar listGet = function (objects, key) {\n  var node = listGetNode(objects, key);\n  return node && node.value;\n};\n\nvar listSet = function (objects, key, value) {\n  var node = listGetNode(objects, key);\n\n  if (node) {\n    node.value = value;\n  } else {\n    // Prepend the new node to the beginning of the list\n    objects.next = {\n      // eslint-disable-line no-param-reassign\n      key: key,\n      next: objects.next,\n      value: value\n    };\n  }\n};\n\nvar listHas = function (objects, key) {\n  return !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n  var $wm;\n  var $m;\n  var $o;\n  var channel = {\n    assert: function (key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    get: function (key) {\n      // eslint-disable-line consistent-return\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapGet($wm, key);\n        }\n      } else if ($Map) {\n        if ($m) {\n          return $mapGet($m, key);\n        }\n      } else {\n        if ($o) {\n          // eslint-disable-line no-lonely-if\n          return listGet($o, key);\n        }\n      }\n    },\n    has: function (key) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapHas($wm, key);\n        }\n      } else if ($Map) {\n        if ($m) {\n          return $mapHas($m, key);\n        }\n      } else {\n        if ($o) {\n          // eslint-disable-line no-lonely-if\n          return listHas($o, key);\n        }\n      }\n\n      return false;\n    },\n    set: function (key, value) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if (!$wm) {\n          $wm = new $WeakMap();\n        }\n\n        $weakMapSet($wm, key, value);\n      } else if ($Map) {\n        if (!$m) {\n          $m = new $Map();\n        }\n\n        $mapSet($m, key, value);\n      } else {\n        if (!$o) {\n          /*\r\n           * Initialize the linked list as an empty node, so that we don't have\r\n           * to special-case handling of the first node: we can always refer to\r\n           * it as (previous node).next, instead of something like (list).head\r\n           */\n          $o = {\n            key: {},\n            next: null\n          };\n        }\n\n        listSet($o, key, value);\n      }\n    }\n  };\n  return channel;\n};","map":{"version":3,"names":["GetIntrinsic","require","callBound","inspect","$TypeError","$WeakMap","$Map","$weakMapGet","$weakMapSet","$weakMapHas","$mapGet","$mapSet","$mapHas","listGetNode","list","key","prev","curr","next","listGet","objects","node","value","listSet","listHas","module","exports","getSideChannel","$wm","$m","$o","channel","assert","has","get","set"],"sources":["C:/webKode/my_repo/node_modules/side-channel/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar GetIntrinsic = require('get-intrinsic');\r\nvar callBound = require('call-bind/callBound');\r\nvar inspect = require('object-inspect');\r\n\r\nvar $TypeError = GetIntrinsic('%TypeError%');\r\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\r\nvar $Map = GetIntrinsic('%Map%', true);\r\n\r\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\r\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\r\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\r\nvar $mapGet = callBound('Map.prototype.get', true);\r\nvar $mapSet = callBound('Map.prototype.set', true);\r\nvar $mapHas = callBound('Map.prototype.has', true);\r\n\r\n/*\r\n * This function traverses the list returning the node corresponding to the\r\n * given key.\r\n *\r\n * That node is also moved to the head of the list, so that if it's accessed\r\n * again we don't need to traverse the whole list. By doing so, all the recently\r\n * used nodes can be accessed relatively quickly.\r\n */\r\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\r\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\r\n\t\tif (curr.key === key) {\r\n\t\t\tprev.next = curr.next;\r\n\t\t\tcurr.next = list.next;\r\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\r\n\t\t\treturn curr;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar listGet = function (objects, key) {\r\n\tvar node = listGetNode(objects, key);\r\n\treturn node && node.value;\r\n};\r\nvar listSet = function (objects, key, value) {\r\n\tvar node = listGetNode(objects, key);\r\n\tif (node) {\r\n\t\tnode.value = value;\r\n\t} else {\r\n\t\t// Prepend the new node to the beginning of the list\r\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\r\n\t\t\tkey: key,\r\n\t\t\tnext: objects.next,\r\n\t\t\tvalue: value\r\n\t\t};\r\n\t}\r\n};\r\nvar listHas = function (objects, key) {\r\n\treturn !!listGetNode(objects, key);\r\n};\r\n\r\nmodule.exports = function getSideChannel() {\r\n\tvar $wm;\r\n\tvar $m;\r\n\tvar $o;\r\n\tvar channel = {\r\n\t\tassert: function (key) {\r\n\t\t\tif (!channel.has(key)) {\r\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\r\n\t\t\t}\r\n\t\t},\r\n\t\tget: function (key) { // eslint-disable-line consistent-return\r\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\r\n\t\t\t\tif ($wm) {\r\n\t\t\t\t\treturn $weakMapGet($wm, key);\r\n\t\t\t\t}\r\n\t\t\t} else if ($Map) {\r\n\t\t\t\tif ($m) {\r\n\t\t\t\t\treturn $mapGet($m, key);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\r\n\t\t\t\t\treturn listGet($o, key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\thas: function (key) {\r\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\r\n\t\t\t\tif ($wm) {\r\n\t\t\t\t\treturn $weakMapHas($wm, key);\r\n\t\t\t\t}\r\n\t\t\t} else if ($Map) {\r\n\t\t\t\tif ($m) {\r\n\t\t\t\t\treturn $mapHas($m, key);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\r\n\t\t\t\t\treturn listHas($o, key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tset: function (key, value) {\r\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\r\n\t\t\t\tif (!$wm) {\r\n\t\t\t\t\t$wm = new $WeakMap();\r\n\t\t\t\t}\r\n\t\t\t\t$weakMapSet($wm, key, value);\r\n\t\t\t} else if ($Map) {\r\n\t\t\t\tif (!$m) {\r\n\t\t\t\t\t$m = new $Map();\r\n\t\t\t\t}\r\n\t\t\t\t$mapSet($m, key, value);\r\n\t\t\t} else {\r\n\t\t\t\tif (!$o) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\r\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\r\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\r\n\t\t\t\t\t */\r\n\t\t\t\t\t$o = { key: {}, next: null };\r\n\t\t\t\t}\r\n\t\t\t\tlistSet($o, key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn channel;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}