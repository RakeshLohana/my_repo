{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global[\"fast-copy\"] = factory());\n})(this, function () {\n  'use strict';\n\n  var toStringFunction = Function.prototype.toString;\n  var create = Object.create,\n      defineProperty = Object.defineProperty,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      getPrototypeOf$1 = Object.getPrototypeOf;\n  var _a = Object.prototype,\n      hasOwnProperty = _a.hasOwnProperty,\n      propertyIsEnumerable = _a.propertyIsEnumerable;\n  var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\n  var WEAK_MAP = typeof WeakMap === 'function';\n  /**\r\n   * @function createCache\r\n   *\r\n   * @description\r\n   * get a new cache object to prevent circular references\r\n   *\r\n   * @returns the new cache object\r\n   */\n\n  var createCache = function () {\n    if (WEAK_MAP) {\n      return function () {\n        return new WeakMap();\n      };\n    }\n\n    var Cache =\n    /** @class */\n    function () {\n      function Cache() {\n        this._keys = [];\n        this._values = [];\n      }\n\n      Cache.prototype.has = function (key) {\n        return !!~this._keys.indexOf(key);\n      };\n\n      Cache.prototype.get = function (key) {\n        return this._values[this._keys.indexOf(key)];\n      };\n\n      Cache.prototype.set = function (key, value) {\n        this._keys.push(key);\n\n        this._values.push(value);\n      };\n\n      return Cache;\n    }();\n\n    return function () {\n      return new Cache();\n    };\n  }();\n  /**\r\n   * @function getCleanClone\r\n   *\r\n   * @description\r\n   * get an empty version of the object with the same prototype it has\r\n   *\r\n   * @param object the object to build a clean clone from\r\n   * @param realm the realm the object resides in\r\n   * @returns the empty cloned object\r\n   */\n\n\n  var getCleanClone = function (object, realm) {\n    var prototype = object.__proto__ || getPrototypeOf$1(object);\n\n    if (!prototype) {\n      return create(null);\n    }\n\n    var Constructor = prototype.constructor;\n\n    if (Constructor === realm.Object) {\n      return prototype === realm.Object.prototype ? {} : create(prototype);\n    }\n\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n      try {\n        return new Constructor();\n      } catch (_a) {}\n    }\n\n    return create(prototype);\n  };\n  /**\r\n   * @function getObjectCloneLoose\r\n   *\r\n   * @description\r\n   * get a copy of the object based on loose rules, meaning all enumerable keys\r\n   * and symbols are copied, but property descriptors are not considered\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneLoose = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        clone[key] = handleCopy(object[key], cache);\n      }\n    }\n\n    if (SYMBOL_PROPERTIES) {\n      var symbols = getOwnPropertySymbols(object);\n\n      for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getObjectCloneStrict\r\n   *\r\n   * @description\r\n   * get a copy of the object based on strict rules, meaning all keys and symbols\r\n   * are copied based on the original property descriptors\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneStrict = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n    var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);\n\n    for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getRegExpFlags\r\n   *\r\n   * @description\r\n   * get the flags to apply to the copied regexp\r\n   *\r\n   * @param regExp the regexp to get the flags of\r\n   * @returns the flags for the regexp\r\n   */\n\n\n  var getRegExpFlags = function (regExp) {\n    var flags = '';\n\n    if (regExp.global) {\n      flags += 'g';\n    }\n\n    if (regExp.ignoreCase) {\n      flags += 'i';\n    }\n\n    if (regExp.multiline) {\n      flags += 'm';\n    }\n\n    if (regExp.unicode) {\n      flags += 'u';\n    }\n\n    if (regExp.sticky) {\n      flags += 'y';\n    }\n\n    return flags;\n  }; // utils\n\n\n  var isArray = Array.isArray;\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  var GLOBAL_THIS = function () {\n    if (typeof globalThis !== 'undefined') {\n      return globalThis;\n    }\n\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    if (console && console.error) {\n      console.error('Unable to locate global object, returning \"this\".');\n    }\n\n    return this;\n  }();\n  /**\r\n   * @function copy\r\n   *\r\n   * @description\r\n   * copy an value deeply as much as possible\r\n   *\r\n   * If `strict` is applied, then all properties (including non-enumerable ones)\r\n   * are copied with their original property descriptors on both objects and arrays.\r\n   *\r\n   * The value is compared to the global constructors in the `realm` provided,\r\n   * and the native constructor is always used to ensure that extensions of native\r\n   * objects (allows in ES2015+) are maintained.\r\n   *\r\n   * @param value the value to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.isStrict] should the copy be strict\r\n   * @param [options.realm] the realm (this) value the value is copied from\r\n   * @returns the copied value\r\n   */\n\n\n  function copy(value, options) {\n    // manually coalesced instead of default parameters for performance\n    var isStrict = !!(options && options.isStrict);\n    var realm = options && options.realm || GLOBAL_THIS;\n    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n    /**\r\n     * @function handleCopy\r\n     *\r\n     * @description\r\n     * copy the value recursively based on its type\r\n     *\r\n     * @param value the value to copy\r\n     * @returns the copied value\r\n     */\n\n    var handleCopy = function (value, cache) {\n      if (!value || typeof value !== 'object') {\n        return value;\n      }\n\n      if (cache.has(value)) {\n        return cache.get(value);\n      }\n\n      var prototype = value.__proto__ || getPrototypeOf(value);\n      var Constructor = prototype && prototype.constructor; // plain objects\n\n      if (!Constructor || Constructor === realm.Object) {\n        return getObjectClone(value, realm, handleCopy, cache);\n      }\n\n      var clone; // arrays\n\n      if (isArray(value)) {\n        // if strict, include non-standard properties\n        if (isStrict) {\n          return getObjectCloneStrict(value, realm, handleCopy, cache);\n        }\n\n        clone = new Constructor();\n        cache.set(value, clone);\n\n        for (var index = 0, length_1 = value.length; index < length_1; ++index) {\n          clone[index] = handleCopy(value[index], cache);\n        }\n\n        return clone;\n      } // dates\n\n\n      if (value instanceof realm.Date) {\n        return new Constructor(value.getTime());\n      } // regexps\n\n\n      if (value instanceof realm.RegExp) {\n        clone = new Constructor(value.source, value.flags || getRegExpFlags(value));\n        clone.lastIndex = value.lastIndex;\n        return clone;\n      } // maps\n\n\n      if (realm.Map && value instanceof realm.Map) {\n        clone = new Constructor();\n        cache.set(value, clone);\n        value.forEach(function (value, key) {\n          clone.set(key, handleCopy(value, cache));\n        });\n        return clone;\n      } // sets\n\n\n      if (realm.Set && value instanceof realm.Set) {\n        clone = new Constructor();\n        cache.set(value, clone);\n        value.forEach(function (value) {\n          clone.add(handleCopy(value, cache));\n        });\n        return clone;\n      } // blobs\n\n\n      if (realm.Blob && value instanceof realm.Blob) {\n        return value.slice(0, value.size, value.type);\n      } // buffers (node-only)\n\n\n      if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length);\n        cache.set(value, clone);\n        value.copy(clone);\n        return clone;\n      } // arraybuffers / dataviews\n\n\n      if (realm.ArrayBuffer) {\n        // dataviews\n        if (realm.ArrayBuffer.isView(value)) {\n          clone = new Constructor(value.buffer.slice(0));\n          cache.set(value, clone);\n          return clone;\n        } // arraybuffers\n\n\n        if (value instanceof realm.ArrayBuffer) {\n          clone = value.slice(0);\n          cache.set(value, clone);\n          return clone;\n        }\n      } // if the value cannot / should not be cloned, don't\n\n\n      if ( // promise-like\n      typeof value.then === 'function' || // errors\n      value instanceof Error || // weakmaps\n      realm.WeakMap && value instanceof realm.WeakMap || // weaksets\n      realm.WeakSet && value instanceof realm.WeakSet) {\n        return value;\n      } // assume anything left is a custom constructor\n\n\n      return getObjectClone(value, realm, handleCopy, cache);\n    };\n\n    return handleCopy(value, createCache());\n  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n  // expects there to be a default property on the exported value. See\n  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n\n\n  copy.default = copy;\n  /**\r\n   * @function strictCopy\r\n   *\r\n   * @description\r\n   * copy the value with `strict` option pre-applied\r\n   *\r\n   * @param value the value to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.realm] the realm (this) value the value is copied from\r\n   * @returns the copied value\r\n   */\n\n  copy.strict = function strictCopy(value, options) {\n    return copy(value, {\n      isStrict: true,\n      realm: options ? options.realm : void 0\n    });\n  };\n\n  return copy;\n});","map":{"version":3,"mappings":"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","names":["toStringFunction","Function","prototype","toString","Object","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","hasOwnProperty","propertyIsEnumerable","SYMBOL_PROPERTIES","WEAK_MAP","WeakMap","createCache","_keys","_values","Cache","has","key","indexOf","get","value","push","getCleanClone","object","realm","__proto__","create","Constructor","constructor","call","getObjectCloneLoose","handleCopy","cache","clone","set","symbols","index","length_1","length","symbol","getObjectCloneStrict","properties","concat","length_2","property","descriptor","error","getRegExpFlags","regExp","flags","global","ignoreCase","multiline","unicode","sticky","Array","GLOBAL_THIS","globalThis","self","window","console","copy","options","isStrict","getObjectClone","isArray","Date","getTime","RegExp","source","lastIndex","Map","forEach","Set","add","Blob","slice","size","type","Buffer","isBuffer","allocUnsafe","ArrayBuffer","isView","buffer","then","Error","WeakSet","default","strict","strictCopy"],"sources":["C:\\Users\\S.A COMPUTER\\OneDrive\\Desktop\\web project\\my_repo\\node_modules\\src\\utils.ts","C:\\Users\\S.A COMPUTER\\OneDrive\\Desktop\\web project\\my_repo\\node_modules\\src\\index.ts"],"sourcesContent":["const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nconst SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\nconst WEAK_MAP = typeof WeakMap === 'function';\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (() => {\n  if (WEAK_MAP) {\n    return (): FastCopy.Cache => new WeakMap();\n  }\n\n  class Cache {\n    _keys: any[] = [];\n    _values: any[] = [];\n\n    has(key: any) {\n      return !!~this._keys.indexOf(key);\n    }\n\n    get(key: any) {\n      return this._values[this._keys.indexOf(key)];\n    }\n\n    set(key: any, value: any) {\n      this._keys.push(key);\n      this._values.push(value);\n    }\n  }\n\n  return (): FastCopy.Cache => new Cache();\n})();\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (!prototype) {\n    return create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    for (\n      let index = 0, length = symbols.length, symbol;\n      index < length;\n      ++index\n    ) {\n      symbol = symbols[index];\n\n      if (propertyIsEnumerable.call(object, symbol)) {\n        clone[symbol] = handleCopy(object[symbol], cache);\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat(\n        getOwnPropertySymbols(object) as unknown as string[],\n      )\n    : getOwnPropertyNames(object);\n\n  for (\n    let index = 0, length = properties.length, property, descriptor;\n    index < length;\n    ++index\n  ) {\n    property = properties[index];\n\n    if (property !== 'callee' && property !== 'caller') {\n      descriptor = getOwnPropertyDescriptor(object, property);\n\n      if (descriptor) {\n        // Only clone the value if actually a value, not a getter / setter.\n        if (!descriptor.get && !descriptor.set) {\n          descriptor.value = handleCopy(object[property], cache);\n        }\n\n        try {\n          defineProperty(clone, property, descriptor);\n        } catch (error) {\n          // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n          clone[property] = descriptor.value;\n        }\n      } else {\n        // In extra edge cases where the property descriptor cannot be retrived, fall back to\n        // the loose assignment.\n        clone[property] = handleCopy(object[property], cache);\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport {\n  createCache,\n  getObjectCloneLoose,\n  getObjectCloneStrict,\n  getRegExpFlags,\n} from './utils';\n\nconst { isArray } = Array;\nconst { getPrototypeOf } = Object;\n\nconst GLOBAL_THIS: FastCopy.Realm = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n\n  return this;\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an value deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The value is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param value the value to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) value the value is copied from\n * @returns the copied value\n */\nfunction copy<Value>(value: Value, options?: FastCopy.Options): Value {\n  // manually coalesced instead of default parameters for performance\n  const isStrict = !!(options && options.isStrict);\n  const realm = (options && options.realm) || GLOBAL_THIS;\n  const getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the value recursively based on its type\n   *\n   * @param value the value to copy\n   * @returns the copied value\n   */\n  const handleCopy: FastCopy.Copier = (\n    value: any,\n    cache: FastCopy.Cache,\n  ): any => {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (cache.has(value)) {\n      return cache.get(value);\n    }\n\n    const prototype = value.__proto__ || getPrototypeOf(value);\n    const Constructor = prototype && prototype.constructor;\n\n    // plain objects\n    if (!Constructor || Constructor === realm.Object) {\n      return getObjectClone(value, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n\n    // arrays\n    if (isArray(value)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(value, realm, handleCopy, cache);\n      }\n\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      for (\n        let index: number = 0, length = value.length;\n        index < length;\n        ++index\n      ) {\n        clone[index] = handleCopy(value[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (value instanceof realm.Date) {\n      return new Constructor(value.getTime());\n    }\n\n    // regexps\n    if (value instanceof realm.RegExp) {\n      clone = new Constructor(\n        value.source,\n        value.flags || getRegExpFlags(value),\n      );\n\n      clone.lastIndex = value.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && value instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      value.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && value instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      value.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && value instanceof realm.Blob) {\n      return value.slice(0, value.size, value.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(value.length)\n        : new Constructor(value.length);\n\n      cache.set(value, clone);\n      value.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(value)) {\n        clone = new Constructor(value.buffer.slice(0));\n        cache.set(value, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (value instanceof realm.ArrayBuffer) {\n        clone = value.slice(0);\n        cache.set(value, clone);\n        return clone;\n      }\n    }\n\n    // if the value cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof value.then === 'function' ||\n      // errors\n      value instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && value instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && value instanceof realm.WeakSet)\n    ) {\n      return value;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(value, realm, handleCopy, cache);\n  };\n\n  return handleCopy(value, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported value. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the value with `strict` option pre-applied\n *\n * @param value the value to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) value the value is copied from\n * @returns the copied value\n */\ncopy.strict = function strictCopy(value: any, options?: FastCopy.Options) {\n  return copy(value, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n"]},"metadata":{},"sourceType":"script"}